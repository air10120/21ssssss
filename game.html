<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç”Ÿæ—¥ç¾Šäº†ä¸ªç¾Š - ä¼˜åŒ–ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            overflow-x: hidden;
            position: relative;
            font-family: 'Arial Rounded MT Bold', 'Microsoft YaHei', sans-serif;
        }
        
        .header {
            text-align: center;
            margin: 8px 0 12px;
            color: #ff6b6b;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 500px;
            position: relative;
            z-index: 10;
        }
        
        .header h1 {
            font-size: 1.6rem;
            margin-bottom: 4px;
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-block;
            padding: 0 8px;
        }
        
        .header p {
            font-size: 0.9rem;
            margin-top: 2px;
            color: #5a3e36;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }
        
        .stats-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 10px;
            padding: 6px 12px;
            margin-bottom: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 50px;
        }
        
        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ff6b6b;
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: #5a3e36;
        }
        
        #game-board {
            position: relative;
            width: 100%;
            height: 280px;
            background: rgba(255, 237, 237, 0.7);
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(255, 107, 107, 0.2);
            margin-bottom: 12px;
            overflow: hidden;
            perspective: 1000px;
        }
        
        .card {
            position: absolute;
            width: 45px;
            height: 55px;
            border-radius: 6px;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 5;
            transform-style: preserve-3d;
            transform: translateZ(0);
        }
        
        .card:active {
            transform: scale(0.85) translateZ(0);
            box-shadow: 0 0 10px #ff6b6b;
            z-index: 100;
        }
        
        .card.covered {
            background: linear-gradient(135deg, #ffd166, #ff9a9e);
            color: rgba(255, 255, 255, 0.7);
        }
        
        .card.covered::after {
            content: "?";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            color: white;
            font-weight: bold;
        }
        
        .slot-area {
            display: flex;
            justify-content: center;
            gap: 5px;
            height: 60px;
            width: 100%;
            margin-top: 6px;
            padding: 8px;
            background: rgba(255, 214, 214, 0.6);
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            flex-wrap: wrap;
        }
        
        .slot {
            width: 40px;
            height: 40px;
            border: 2px dashed #ff6b6b;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.6);
            transition: all 0.2s;
            position: relative;
        }
        
        .slot.filled {
            border-style: solid;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .powerups {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .powerup {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            position: relative;
        }
        
        .powerup-count {
            position: absolute;
            bottom: -3px;
            right: -3px;
            background: #ff6b6b;
            color: white;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 9px;
            font-weight: bold;
        }
        
        .powerup:active {
            transform: scale(0.95);
        }
        
        .powerup.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        button {
            padding: 7px 12px;
            border: none;
            border-radius: 30px;
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            font-weight: bold;
            font-size: 0.85rem;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(255, 107, 107, 0.3);
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        #message {
            margin-top: 12px;
            min-height: 35px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #ff6b6b;
            text-align: center;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 30px;
            width: 100%;
            max-width: 450px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* çƒŸèŠ±ç‰¹æ•ˆå®¹å™¨ */
        #fireworks {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }
        
        .level-indicator {
            position: absolute;
            top: 12px;
            right: 12px;
            background: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            color: #ff6b6b;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            z-index: 20;
            font-size: 0.8rem;
        }
        
        .difficulty-info {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 10px;
            margin-top: 12px;
            max-width: 450px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            text-align: center;
            font-size: 0.8rem;
        }
        
        .difficulty-info h3 {
            color: #ff6b6b;
            margin-bottom: 6px;
            font-size: 1rem;
        }
        
        .difficulty-info p {
            margin-bottom: 5px;
            line-height: 1.3;
        }
        
        .level-progress {
            width: 100%;
            height: 12px;
            background: rgba(255, 107, 107, 0.2);
            border-radius: 6px;
            margin-top: 6px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
            border-radius: 6px;
            width: 0%;
            transition: width 0.4s ease;
        }
        
        /* æ€§èƒ½æ¨¡å¼å¼€å…³ */
        .performance-toggle {
            position: absolute;
            top: 12px;
            left: 12px;
            background: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            color: #ff6b6b;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            z-index: 20;
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        /* å †å æ•ˆæœå¢å¼º */
        .card.stack-1 {
            transform: translate(-1px, -1px) rotate(-1deg) translateZ(1px);
        }
        
        .card.stack-2 {
            transform: translate(1px, 1px) rotate(1deg) translateZ(2px);
        }
        
        .card.stack-3 {
            transform: translate(-2px, 2px) rotate(-2deg) translateZ(3px);
        }
        
        .card.stack-4 {
            transform: translate(2px, -1px) rotate(2deg) translateZ(4px);
        }
        
        .card.stack-5 {
            transform: translate(0px, 2px) rotate(0deg) translateZ(5px);
        }
        
        /* ç§»åŠ¨è®¾å¤‡ç‰¹å®šæ ·å¼ */
        @media (max-width: 480px) {
            .header h1 { font-size: 1.4rem; }
            .header p { font-size: 0.8rem; }
            #game-board { height: 230px; }
            .stat-value { font-size: 1rem; }
            .stat-label { font-size: 0.65rem; }
            .card { width: 40px; height: 50px; font-size: 22px; }
            .slot { width: 36px; height: 36px; font-size: 18px; }
            .powerup { width: 36px; height: 36px; font-size: 16px; }
            button { padding: 6px 10px; font-size: 0.8rem; }
            .difficulty-info { padding: 8px; font-size: 0.75rem; }
            .difficulty-info h3 { font-size: 0.9rem; }
        }
        
        @media (max-width: 360px) {
            .header h1 { font-size: 1.3rem; }
            #game-board { height: 200px; }
            .card { width: 36px; height: 45px; font-size: 20px; }
            .slot { width: 32px; height: 32px; font-size: 16px; }
            .powerup { width: 32px; height: 32px; font-size: 15px; }
            .difficulty-info { font-size: 0.7rem; }
            .difficulty-info h3 { font-size: 0.85rem; }
            button { font-size: 0.75rem; }
        }
        
        /* æ¨ªå±æ¨¡å¼ä¼˜åŒ– */
        @media (orientation: landscape) and (max-height: 500px) {
            .header { margin: 3px 0; }
            .header h1 { font-size: 1.2rem; }
            .header p { display: none; }
            .stats-bar { padding: 4px 8px; margin-bottom: 4px; }
            #game-board { height: 150px; margin-bottom: 4px; }
            .slot-area { height: 45px; padding: 4px; }
            .controls { margin-top: 4px; }
            .powerups { margin-top: 4px; }
            .difficulty-info { display: none; }
            #message { margin-top: 4px; min-height: 25px; font-size: 0.8rem; padding: 4px 8px; }
            .card { width: 35px; height: 45px; }
        }
        
        /* å †å æŒ‡ç¤ºå™¨ */
        .stack-indicator {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 10px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        /* æ–°æ·»åŠ çš„æç¤ºæ•ˆæœ */
        .hint-highlight {
            animation: pulse 1s infinite;
            box-shadow: 0 0 10px gold;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .covered-count {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 10px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="performance-toggle" id="perf-toggle">âš¡æ€§èƒ½æ¨¡å¼</div>
    
    <div class="header">
        <h1>ğŸ‚ ç”Ÿæ—¥ç¾Šäº†ä¸ªç¾Š ğŸ</h1>
        <p>æ”¶é›†ç›¸åŒçš„ç”Ÿæ—¥å…ƒç´ ï¼Œä¸‰ä¸ªä¸€ç»„æ¶ˆé™¤ï¼</p>
    </div>
    
    <div class="level-indicator">å…³å¡: <span id="level">1</span></div>
    
    <div class="game-container">
        <div class="stats-bar">
            <div class="stat">
                <div class="stat-value" id="moves">0</div>
                <div class="stat-label">æ­¥æ•°</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="score">0</div>
                <div class="stat-label">åˆ†æ•°</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="remaining">25</div>
                <div class="stat-label">å‰©ä½™å¡ç‰‡</div>
            </div>
        </div>
        
        <div id="game-board"></div>
        
        <div class="slot-area" id="slot-area">
            <!-- å¡æ§½å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
        </div>
        
        <div class="powerups">
            <div class="powerup" id="shuffle-power" title="æ´—ç‰Œ">
                ğŸ”€
                <div class="powerup-count" id="shuffle-count">3</div>
            </div>
            <div class="powerup" id="undo-power" title="æ’¤é”€">
                â†©ï¸
                <div class="powerup-count" id="undo-count">5</div>
            </div>
            <div class="powerup" id="hint-power" title="æç¤º">
                ğŸ’¡
                <div class="powerup-count" id="hint-count">2</div>
            </div>
            <div class="powerup" id="bomb-power" title="æ¶ˆé™¤">
                ğŸ’£
                <div class="powerup-count" id="bomb-count">2</div>
            </div>
        </div>
        
        <div class="controls">
            <button id="shuffle">ğŸ”€ æ´—ç‰Œ</button>
            <button id="undo">â†©ï¸ æ’¤é”€</button>
            <button id="restart">ğŸ”„ é‡ç©</button>
        </div>
        
        <div id="message">ç¥æ‚¨ç”Ÿæ—¥å¿«ä¹ï¼ç‚¹å‡»å¡ç‰‡å¼€å§‹æ¸¸æˆ~</div>
    </div>
    
    <div class="difficulty-info">
        <h3>å½“å‰å…³å¡éš¾åº¦</h3>
        <p>å¡ç‰‡ç§ç±»: <span id="card-types">6</span> | å¡ç‰‡æ€»æ•°: <span id="total-cards">25</span></p>
        <p>å¡æ§½æ•°é‡: <span id="slot-count">7</span> | è¦†ç›–å±‚æ•°: <span id="layer-count">3</span></p>
        <div class="level-progress">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
    </div>
    
    <div id="fireworks"></div>

    <script>
        // ç”Ÿæ—¥ä¸»é¢˜å…ƒç´ 
        const BIRTHDAY_ITEMS = ['ğŸ‚', 'ğŸ', 'ğŸˆ', 'ğŸ‰', 'ğŸ•¯ï¸', 'ğŸ°', 'ğŸ¬', 'ğŸ€', 'ğŸ­', 'ğŸ¥³', 'ğŸŠ', 'ğŸ†'];
        
        // æ¸¸æˆé…ç½®
        const DIFFICULTY_SETTINGS = {
            typesPerLevel: 1,
            cardsPerLevel: 3,
            slotsReductionPerTwoLevels: 1,
            layersPerThreeLevels: 1,
            baseTypes: 6,
            baseCards: 25,
            baseSlots: 7,
            baseLayers: 3
        };
        
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            board: [],
            slots: [],
            selectedCard: null,
            moves: 0,
            score: 0,
            level: 1,
            history: [],
            powerups: {
                shuffle: 3,
                undo: 5,
                hint: 2,
                bomb: 2
            },
            cards: [],
            cardData: [],
            isAnimating: false,
            lowPerfMode: false,
            coveredCards: {} // è·Ÿè¸ªæ¯å¼ å¡ç‰‡è¢«è¦†ç›–çš„æ•°é‡
        };
        
        // DOM å…ƒç´ 
        const gameBoard = document.getElementById('game-board');
        const slotArea = document.getElementById('slot-area');
        const messageEl = document.getElementById('message');
        const movesEl = document.getElementById('moves');
        const scoreEl = document.getElementById('score');
        const remainingEl = document.getElementById('remaining');
        const levelEl = document.getElementById('level');
        const cardTypesEl = document.getElementById('card-types');
        const totalCardsEl = document.getElementById('total-cards');
        const slotCountEl = document.getElementById('slot-count');
        const layerCountEl = document.getElementById('layer-count');
        const progressBar = document.getElementById('progress-bar');
        const perfToggle = document.getElementById('perf-toggle');
        
        // è®¡ç®—å½“å‰å…³å¡éš¾åº¦
        function calculateDifficulty() {
            const level = gameState.level;
            
            const cardTypes = Math.min(
                DIFFICULTY_SETTINGS.baseTypes + (level - 1) * DIFFICULTY_SETTINGS.typesPerLevel,
                BIRTHDAY_ITEMS.length
            );
            
            // ç¡®ä¿å¡ç‰‡æ€»æ•°æ˜¯3çš„å€æ•°
            let totalCards = DIFFICULTY_SETTINGS.baseCards + (level - 1) * DIFFICULTY_SETTINGS.cardsPerLevel;
            totalCards = totalCards - (totalCards % 3);
            
            const slotCount = Math.max(
                3, 
                DIFFICULTY_SETTINGS.baseSlots - Math.floor((level - 1) / 2) * DIFFICULTY_SETTINGS.slotsReductionPerTwoLevels
            );
            
            const layers = Math.min(
                5, 
                DIFFICULTY_SETTINGS.baseLayers + Math.floor((level - 1) / 3) * DIFFICULTY_SETTINGS.layersPerThreeLevels
            );
            
            cardTypesEl.textContent = cardTypes;
            totalCardsEl.textContent = totalCards;
            slotCountEl.textContent = slotCount;
            layerCountEl.textContent = layers;
            progressBar.style.width = `${Math.min(100, level * 8)}%`;
            
            return { cardTypes, totalCards, slotCount, layers };
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            const difficulty = calculateDifficulty();
            
            gameState.board = [];
            gameState.slots = Array(difficulty.slotCount).fill(null);
            gameState.selectedCard = null;
            gameState.history = [];
            gameState.cards = [];
            gameState.cardData = [];
            gameState.isAnimating = false;
            gameState.coveredCards = {};
            
            gameState.powerups = {
                shuffle: Math.max(1, 4 - Math.floor(gameState.level / 3)),
                undo: Math.max(1, 6 - Math.floor(gameState.level / 2)),
                hint: Math.max(1, 3 - Math.floor(gameState.level / 4)),
                bomb: Math.max(1, 3 - Math.floor(gameState.level / 4))
            };
            
            updatePowerups();
            
            movesEl.textContent = gameState.moves;
            scoreEl.textContent = gameState.score;
            remainingEl.textContent = difficulty.totalCards;
            levelEl.textContent = gameState.level;
            messageEl.textContent = `ç¬¬${gameState.level}å…³ï¼šç¥æ‚¨ç”Ÿæ—¥å¿«ä¹ï¼`;
            
            const items = [];
            const cardTypes = difficulty.cardTypes;
            const totalCards = difficulty.totalCards;
            
            // ç¡®ä¿æ¯ç§ç±»å‹çš„å¡ç‰‡æ•°é‡æ˜¯3çš„å€æ•°
            const cardsPerType = Math.floor(totalCards / cardTypes);
            let baseCards = cardsPerType - (cardsPerType % 3);
            let remainingCards = totalCards - (baseCards * cardTypes);
            
            for (let i = 0; i < cardTypes; i++) {
                const item = BIRTHDAY_ITEMS[i % BIRTHDAY_ITEMS.length];
                for (let j = 0; j < baseCards; j++) {
                    items.push(item);
                }
            }
            
            // åˆ†é…å‰©ä½™çš„å¡ç‰‡ï¼ˆä»¥3ä¸ºå•ä½ï¼‰
            while (remainingCards > 0) {
                const randomType = Math.floor(Math.random() * cardTypes);
                const item = BIRTHDAY_ITEMS[randomType % BIRTHDAY_ITEMS.length];
                for (let j = 0; j < 3; j++) {
                    items.push(item);
                }
                remainingCards -= 3;
            }
            
            shuffleArray(items);
            
            gameBoard.innerHTML = '';
            gameState.board = items;
            
            renderCards(difficulty.layers);
            
            createSlots(difficulty.slotCount);
        }
        
        // åˆ›å»ºå¡æ§½
        function createSlots(slotCount) {
            slotArea.innerHTML = '';
            for (let i = 0; i < slotCount; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.dataset.index = i;
                slotArea.appendChild(slot);
            }
        }
        
        // æ¸²æŸ“å¡ç‰‡ï¼ˆå¢åŠ å †å æ•ˆæœï¼‰
        function renderCards(maxLayers) {
            gameBoard.innerHTML = '';
            gameState.cards = [];
            gameState.cardData = [];
            gameState.coveredCards = {};
            
            const boardWidth = gameBoard.clientWidth;
            const boardHeight = gameBoard.clientHeight;
            
            // æ ¹æ®å±å¹•å°ºå¯¸è°ƒæ•´å¡ç‰‡å¤§å°
            const cardWidth = window.innerWidth < 480 ? 40 : 45;
            const cardHeight = window.innerWidth < 480 ? 50 : 55;
            
            // ç½‘æ ¼å¸ƒå±€å‚æ•°
            let gridCols = Math.max(1, Math.floor(boardWidth / (cardWidth + 8)));
            let gridRows = Math.max(1, Math.floor(boardHeight / (cardHeight + 8)));
            
            // ç¡®ä¿ç½‘æ ¼å¯ä»¥å®¹çº³æ‰€æœ‰å¡ç‰‡
            while (gridCols * gridRows < gameState.board.length) {
                if (gridCols < gridRows) {
                    gridCols++;
                } else {
                    gridRows++;
                }
            }
            
            const gridSize = gridCols * gridRows;
            
            // åˆ›å»ºç½‘æ ¼ä½ç½®
            const gridPositions = [];
            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const x = col * (cardWidth + 8) + 10;
                    const y = row * (cardHeight + 8) + 10;
                    gridPositions.push({x, y});
                }
            }
            
            // æ‰“ä¹±ç½‘æ ¼ä½ç½®
            shuffleArray(gridPositions);
            
            // å †å è®¡æ•°å™¨
            const stackCount = {};
            
            // ä¸ºæ¯å¼ å¡ç‰‡åˆ†é…ä½ç½®
            for (let i = 0; i < gameState.board.length; i++) {
                const pos = gridPositions[i % gridSize];
                
                // è®¡ç®—å †å ä½ç½®
                const stackKey = `${Math.floor(pos.x/10)}-${Math.floor(pos.y/10)}`;
                stackCount[stackKey] = (stackCount[stackKey] || 0) + 1;
                const stackLevel = stackCount[stackKey] % 5;
                
                // éšæœºæ—‹è½¬è§’åº¦
                const rotation = (Math.random() - 0.5) * 10;
                
                // éšæœºå±‚çº§
                const zIndex = Math.floor(Math.random() * maxLayers);
                
                // å­˜å‚¨å¡ç‰‡æ•°æ®
                gameState.cardData.push({
                    x: pos.x, y: pos.y, width: cardWidth, height: cardHeight, zIndex, stackLevel
                });
                
                const card = document.createElement('div');
                card.className = `card stack-${stackLevel}`;
                card.dataset.index = i;
                card.textContent = gameState.board[i];
                card.style.left = `${pos.x}px`;
                card.style.top = `${pos.y}px`;
                card.style.width = `${cardWidth}px`;
                card.style.height = `${cardHeight}px`;
                card.style.zIndex = zIndex;
                
                // æ·»åŠ å †å æŒ‡ç¤ºå™¨
                const stackIndicator = document.createElement('div');
                stackIndicator.className = 'stack-indicator';
                stackIndicator.textContent = stackLevel + 1;
                card.appendChild(stackIndicator);
                
                // æ·»åŠ è¦†ç›–æ•°é‡æŒ‡ç¤ºå™¨
                const coveredIndicator = document.createElement('div');
                coveredIndicator.className = 'covered-count';
                coveredIndicator.textContent = '0';
                card.appendChild(coveredIndicator);
                
                if (zIndex < maxLayers - 1) {
                    card.classList.add('covered');
                }
                
                // æ·»åŠ äº‹ä»¶ç›‘å¬
                card.addEventListener('click', () => selectCard(card, i));
                
                gameBoard.appendChild(card);
                gameState.cards.push(card);
            }
            
            // è®¡ç®—æ¯å¼ å¡ç‰‡è¢«è¦†ç›–çš„æ•°é‡
            calculateCoveredCounts();
        }
        
        // è®¡ç®—æ¯å¼ å¡ç‰‡è¢«è¦†ç›–çš„æ•°é‡
        function calculateCoveredCounts() {
            const maxLayers = calculateDifficulty().layers;
            
            for (let i = 0; i < gameState.cardData.length; i++) {
                const card = gameState.cardData[i];
                if (!card) continue;
                
                let coveredCount = 0;
                
                for (let j = 0; j < gameState.cardData.length; j++) {
                    if (i === j) continue;
                    const otherCard = gameState.cardData[j];
                    if (!otherCard) continue;
                    
                    if (otherCard.zIndex > card.zIndex) {
                        if (isOverlapping(card, otherCard)) {
                            coveredCount++;
                        }
                    }
                }
                
                gameState.coveredCards[i] = coveredCount;
                
                // æ›´æ–°å¡ç‰‡ä¸Šçš„æŒ‡ç¤ºå™¨
                const cardElement = gameState.cards[i];
                if (cardElement) {
                    const coveredIndicator = cardElement.querySelector('.covered-count');
                    if (coveredIndicator) {
                        coveredIndicator.textContent = coveredCount;
                    }
                }
            }
        }
        
        // æ£€æŸ¥ä¸¤å¼ å¡ç‰‡æ˜¯å¦é‡å 
        function isOverlapping(card1, card2) {
            return card1.x < card2.x + card2.width &&
                   card1.x + card1.width > card2.x &&
                   card1.y < card2.y + card2.height &&
                   card1.y + card1.height > card2.y;
        }
        
        // æ´—ç‰Œç®—æ³•
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // å¡ç‰‡ç§»åŠ¨åŠ¨ç”»ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
        function animateCardToSlot(cardElement, slotElement, callback) {
            if (gameState.isAnimating) return;
            
            gameState.isAnimating = true;
            
            const card = cardElement.cloneNode(true);
            card.style.position = 'fixed';
            card.style.left = `${cardElement.getBoundingClientRect().left}px`;
            card.style.top = `${cardElement.getBoundingClientRect().top}px`;
            card.style.zIndex = '1000';
            card.style.transition = 'transform 0.4s ease, opacity 0.4s ease';
            document.body.appendChild(card);
            
            // å¼ºåˆ¶é‡ç»˜
            card.offsetHeight;
            
            const slotRect = slotElement.getBoundingClientRect();
            
            // æ‰§è¡ŒåŠ¨ç”»
            card.style.transform = `translate(${slotRect.left}px, ${slotRect.top}px) scale(0.7)`;
            card.style.opacity = '0.8';
            
            setTimeout(() => {
                card.remove();
                callback();
                gameState.isAnimating = false;
            }, 400);
        }
        
        // æ£€æµ‹å¡ç‰‡æ˜¯å¦è¢«è¦†ç›–
        function isCardCovered(cardIndex) {
            return gameState.coveredCards[cardIndex] > 0;
        }
        
        // é€‰æ‹©å¡ç‰‡
        function selectCard(card, index) {
            if (gameState.isAnimating) return;
            if (isCardCovered(index)) {
                messageEl.textContent = `è¿™å¼ å¡ç‰‡è¢«è¦†ç›–äº†ï¼è¯·å…ˆç§»å¼€ä¸Šå±‚çš„å¡ç‰‡ï¼ˆè¦†ç›–æ•°: ${gameState.coveredCards[index]})`;
                
                const cardElement = gameState.cards[index];
                cardElement.style.boxShadow = '0 0 0 2px red';
                setTimeout(() => {
                    if (cardElement) cardElement.style.boxShadow = '';
                }, 1000);
                
                return;
            }
            
            if (gameState.selectedCard) {
                gameState.selectedCard.classList.remove('selected');
            }
            
            card.classList.add('selected');
            gameState.selectedCard = card;
            
            placeCardInSlot(gameState.board[index]);
        }
        
        // å°†å¡ç‰‡æ”¾å…¥å¡æ§½
        function placeCardInSlot(item) {
            const emptySlotIndex = gameState.slots.findIndex(slot => slot === null);
            
            if (emptySlotIndex === -1) {
                messageEl.textContent = 'å¡æ§½å·²æ»¡ï¼è¯·å…ˆæ¶ˆé™¤å¡ç‰‡';
                return;
            }
            
            const cardIndex = parseInt(gameState.selectedCard.dataset.index);
            const targetSlot = document.querySelector(`.slot[data-index="${emptySlotIndex}"]`);
            
            animateCardToSlot(gameState.selectedCard, targetSlot, () => {
                gameState.history.push({
                    board: [...gameState.board],
                    slots: [...gameState.slots],
                    movedItem: item,
                    slotIndex: emptySlotIndex,
                    selectedIndex: cardIndex
                });
                
                gameState.slots[emptySlotIndex] = item;
                gameState.board[cardIndex] = null;
                gameState.cardData[cardIndex] = null;
                gameState.moves++;
                movesEl.textContent = gameState.moves;
                
                const remaining = gameState.board.filter(item => item !== null).length;
                remainingEl.textContent = remaining;
                
                updateSlots();
                
                gameState.selectedCard.style.visibility = 'hidden';
                gameState.selectedCard.classList.remove('selected');
                gameState.selectedCard = null;
                
                const match = checkForMatches();
                if (!match) {
                    messageEl.textContent = 'ç»§ç»­å¯»æ‰¾ç›¸åŒçš„å…ƒç´ ï¼';
                }
                
                // é‡æ–°è®¡ç®—è¦†ç›–çŠ¶æ€
                calculateCoveredCounts();
                checkGameEnd();
            });
        }
        
        // æ›´æ–°å¡æ§½æ˜¾ç¤º
        function updateSlots() {
            const slots = document.querySelectorAll('.slot');
            slots.forEach((slot, index) => {
                if (gameState.slots[index]) {
                    slot.className = 'slot filled';
                    slot.textContent = gameState.slots[index];
                } else {
                    slot.className = 'slot';
                    slot.innerHTML = '';
                }
            });
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¯æ¶ˆé™¤çš„ç»„åˆ
        function checkForMatches() {
            const slotItems = gameState.slots.filter(item => item !== null);
            const counts = {};
            
            slotItems.forEach(item => {
                counts[item] = (counts[item] || 0) + 1;
            });
            
            for (const item in counts) {
                if (counts[item] >= 3) {
                    let removed = 0;
                    for (let i = 0; i < gameState.slots.length && removed < 3; i++) {
                        if (gameState.slots[i] === item) {
                            gameState.slots[i] = null;
                            removed++;
                        }
                    }
                    
                    gameState.score += 100 * gameState.level;
                    scoreEl.textContent = gameState.score;
                    
                    messageEl.textContent = `æ¶ˆé™¤æˆåŠŸï¼${item} x3 +${100 * gameState.level}åˆ†`;
                    updateSlots();
                    return true;
                }
            }
            return false;
        }
        
        // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
        function checkGameEnd() {
            if (gameState.board.every(item => item === null)) {
                messageEl.textContent = `ğŸ‰ æ­å–œï¼æ‚¨é€šå…³ç¬¬${gameState.level}å…³ï¼`;
                
                // æ˜¾ç¤ºçƒŸèŠ±æ•ˆæœ
                showSimpleFireworks();
                
                setTimeout(() => {
                    gameState.level++;
                    initGame();
                }, 1500);
                return true;
            }
            
            const hasEmptySlot = gameState.slots.some(slot => slot === null);
            if (!hasEmptySlot && !checkForMatches()) {
                messageEl.textContent = 'å¡æ§½æ»¡äº†ï¼æ¸¸æˆç»“æŸ';
                setTimeout(() => {
                    if (confirm(`ç¬¬${gameState.level}å…³å¤±è´¥ï¼æ˜¯å¦é‡æ–°å¼€å§‹ï¼Ÿ`)) {
                        gameState.level = 1;
                        gameState.score = 0;
                        gameState.moves = 0;
                        initGame();
                    }
                }, 500);
                return true;
            }
            
            return false;
        }
        
        // æ˜¾ç¤ºç®€å•çƒŸèŠ±ç‰¹æ•ˆ
        function showSimpleFireworks() {
            const fireworks = document.createElement('div');
            fireworks.style.position = 'fixed';
            fireworks.style.top = '50%';
            fireworks.style.left = '50%';
            fireworks.style.transform = 'translate(-50%, -50%)';
            fireworks.style.fontSize = '60px';
            fireworks.style.zIndex = '100';
            fireworks.style.opacity = '0';
            fireworks.style.transition = 'opacity 0.5s, transform 0.5s';
            fireworks.textContent = 'ğŸ‰';
            
            document.body.appendChild(fireworks);
            
            // è§¦å‘åŠ¨ç”»
            setTimeout(() => {
                fireworks.style.opacity = '1';
                fireworks.style.transform = 'translate(-50%, -50%) scale(1.5)';
            }, 10);
            
            // ç§»é™¤çƒŸèŠ±
            setTimeout(() => {
                fireworks.style.opacity = '0';
                setTimeout(() => fireworks.remove(), 500);
            }, 1000);
        }
        
        // æ’¤é”€æ“ä½œ
        function undoMove() {
            if (gameState.isAnimating) return;
            if (gameState.history.length === 0) {
                messageEl.textContent = 'æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ';
                return;
            }
            
            if (gameState.powerups.undo <= 0) {
                messageEl.textContent = 'æ’¤é”€æ¬¡æ•°å·²ç”¨å®Œ';
                return;
            }
            
            gameState.powerups.undo--;
            updatePowerups();
            
            const lastMove = gameState.history.pop();
            gameState.board = lastMove.board;
            gameState.slots = lastMove.slots;
            gameState.moves--;
            
            updateSlots();
            const difficulty = calculateDifficulty();
            renderCards(difficulty.layers);
            
            if (lastMove.selectedIndex !== null) {
                const card = document.querySelector(`.card[data-index="${lastMove.selectedIndex}"]`);
                if (card) {
                    card.classList.add('selected');
                    card.style.visibility = 'visible';
                    gameState.selectedCard = card;
                }
            }
            
            movesEl.textContent = gameState.moves;
            const remaining = gameState.board.filter(item => item !== null).length;
            remainingEl.textContent = remaining;
            
            messageEl.textContent = 'å·²æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œ';
        }
        
        // æ´—ç‰ŒåŠŸèƒ½
        function shuffleBoard() {
            if (gameState.isAnimating) return;
            if (gameState.powerups.shuffle <= 0) {
                messageEl.textContent = 'æ´—ç‰Œæ¬¡æ•°å·²ç”¨å®Œ';
                return;
            }
            
            gameState.powerups.shuffle--;
            updatePowerups();
            
            const visibleItems = gameState.board.filter(item => item !== null);
            shuffleArray(visibleItems);
            
            let itemIndex = 0;
            gameState.board.forEach((item, index) => {
                if (item !== null) {
                    gameState.board[index] = visibleItems[itemIndex++];
                }
            });
            
            const difficulty = calculateDifficulty();
            renderCards(difficulty.layers);
            messageEl.textContent = 'å¡ç‰‡å·²æ´—ç‰Œï¼';
        }
        
        // æç¤ºåŠŸèƒ½
        function showHint() {
            if (gameState.isAnimating) return;
            if (gameState.powerups.hint <= 0) {
                messageEl.textContent = 'æç¤ºæ¬¡æ•°å·²ç”¨å®Œ';
                return;
            }
            
            gameState.powerups.hint--;
            updatePowerups();
            
            // 1. é¦–å…ˆæ£€æŸ¥å¡æ§½ä¸­æ˜¯å¦æœ‰ä¸¤ä¸ªç›¸åŒçš„å¡ç‰‡
            const slotCounts = {};
            gameState.slots.forEach(item => {
                if (item) {
                    slotCounts[item] = (slotCounts[item] || 0) + 1;
                }
            });
            
            for (const item in slotCounts) {
                if (slotCounts[item] >= 2) {
                    // å°è¯•åœ¨ç‰Œå †ä¸­æ‰¾åˆ°ç¬¬ä¸‰ä¸ªç›¸åŒçš„å¡ç‰‡
                    for (let i = 0; i < gameState.board.length; i++) {
                        if (gameState.board[i] === item && !isCardCovered(i)) {
                            const card = document.querySelector(`.card[data-index="${i}"]`);
                            if (card) {
                                card.classList.add('hint-highlight');
                                setTimeout(() => {
                                    card.classList.remove('hint-highlight');
                                }, 1500);
                                
                                messageEl.textContent = `å¡æ§½ä¸­æœ‰ä¸¤ä¸ª${item}ï¼Œç‚¹å‡»ç‰Œå †ä¸­çš„${item}å®Œæˆæ¶ˆé™¤ï¼`;
                                return;
                            }
                        }
                    }
                }
            }
            
            // 2. å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¡æ§½ä¸­çš„é…å¯¹ï¼Œåˆ™æ‰¾ç‰Œå †ä¸­çš„é…å¯¹
            let found = false;
            for (let i = 0; i < gameState.board.length && !found; i++) {
                if (gameState.board[i] === null || isCardCovered(i)) continue;
                
                for (let j = i + 1; j < gameState.board.length; j++) {
                    if (gameState.board[j] && gameState.board[i] === gameState.board[j] && !isCardCovered(j)) {
                        const card1 = document.querySelector(`.card[data-index="${i}"]`);
                        const card2 = document.querySelector(`.card[data-index="${j}"]`);
                        
                        if (card1 && card2) {
                            card1.classList.add('hint-highlight');
                            card2.classList.add('hint-highlight');
                            
                            setTimeout(() => {
                                card1.classList.remove('hint-highlight');
                                card2.classList.remove('hint-highlight');
                            }, 1500);
                            
                            messageEl.textContent = 'æ‰¾åˆ°ä¸€å¯¹ç›¸åŒçš„å¡ç‰‡ï¼';
                            found = true;
                            break;
                        }
                    }
                }
            }
            
            if (!found) {
                messageEl.textContent = 'æ²¡æœ‰æ‰¾åˆ°å¯åŒ¹é…çš„å¡ç‰‡';
            }
        }
        
        // ç‚¸å¼¹åŠŸèƒ½
        function useBomb() {
            if (gameState.isAnimating) return;
            if (gameState.powerups.bomb <= 0) {
                messageEl.textContent = 'ç‚¸å¼¹æ¬¡æ•°å·²ç”¨å®Œ';
                return;
            }
            
            gameState.powerups.bomb--;
            updatePowerups();
            
            const slotIndex = gameState.slots.findIndex(slot => slot !== null);
            if (slotIndex === -1) {
                messageEl.textContent = 'å¡æ§½ä¸ºç©ºï¼Œæ— æ³•ä½¿ç”¨ç‚¸å¼¹';
                return;
            }
            
            // ç›´æ¥ç§»é™¤
            gameState.slots[slotIndex] = null;
            updateSlots();
            messageEl.textContent = 'å·²ç§»é™¤ä¸€ä¸ªå¡ç‰‡å…ƒç´ ';
        }
        
        // æ›´æ–°é“å…·æ˜¾ç¤º
        function updatePowerups() {
            document.getElementById('shuffle-count').textContent = gameState.powerups.shuffle;
            document.getElementById('undo-count').textContent = gameState.powerups.undo;
            document.getElementById('hint-count').textContent = gameState.powerups.hint;
            document.getElementById('bomb-count').textContent = gameState.powerups.bomb;
            
            document.getElementById('shuffle-power').classList.toggle('disabled', gameState.powerups.shuffle <= 0);
            document.getElementById('undo-power').classList.toggle('disabled', gameState.powerups.undo <= 0);
            document.getElementById('hint-power').classList.toggle('disabled', gameState.powerups.hint <= 0);
            document.getElementById('bomb-power').classList.toggle('disabled', gameState.powerups.bomb <= 0);
        }
        
        // åˆ‡æ¢æ€§èƒ½æ¨¡å¼
        function togglePerformanceMode() {
            gameState.lowPerfMode = !gameState.lowPerfMode;
            
            if (gameState.lowPerfMode) {
                perfToggle.textContent = 'âš¡æµç•…æ¨¡å¼';
                messageEl.textContent = 'å·²å¯ç”¨æµç•…æ¨¡å¼ï¼ˆå‡å°‘ç‰¹æ•ˆï¼‰';
            } else {
                perfToggle.textContent = 'âš¡æ€§èƒ½æ¨¡å¼';
                messageEl.textContent = 'å·²å¯ç”¨æ€§èƒ½æ¨¡å¼ï¼ˆæ›´å¤šç‰¹æ•ˆï¼‰';
            }
            
            // é‡æ–°æ¸²æŸ“å¡ç‰‡
            const difficulty = calculateDifficulty();
            renderCards(difficulty.layers);
        }
        
        // äº‹ä»¶ç›‘å¬
        document.getElementById('shuffle').addEventListener('click', shuffleBoard);
        document.getElementById('undo').addEventListener('click', undoMove);
        document.getElementById('restart').addEventListener('click', () => {
            gameState.level = 1;
            gameState.score = 0;
            gameState.moves = 0;
            initGame();
        });
        
        document.getElementById('shuffle-power').addEventListener('click', shuffleBoard);
        document.getElementById('undo-power').addEventListener('click', undoMove);
        document.getElementById('hint-power').addEventListener('click', showHint);
        document.getElementById('bomb-power').addEventListener('click', useBomb);
        perfToggle.addEventListener('click', togglePerformanceMode);
        
        // åˆå§‹åŒ–æ¸¸æˆ
        window.onload = () => {
            initGame();
            
            // æ·»åŠ çª—å£å¤§å°å˜åŒ–ç›‘å¬
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (!gameState.isAnimating) {
                        const difficulty = calculateDifficulty();
                        renderCards(difficulty.layers);
                    }
                }, 300);
            });
        };
    </script>
</body>
</html>
