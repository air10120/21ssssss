<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>生日羊了个羊 - 优化版</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            overflow-x: hidden;
            position: relative;
            font-family: 'Arial Rounded MT Bold', 'Microsoft YaHei', sans-serif;
        }
        
        .header {
            text-align: center;
            margin: 8px 0 12px;
            color: #ff6b6b;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 500px;
            position: relative;
            z-index: 10;
        }
        
        .header h1 {
            font-size: 1.6rem;
            margin-bottom: 4px;
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-block;
            padding: 0 8px;
        }
        
        .header p {
            font-size: 0.9rem;
            margin-top: 2px;
            color: #5a3e36;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }
        
        .stats-bar {
            display: flex;
            justify-content: space-between;
            width: 100%;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 10px;
            padding: 6px 12px;
            margin-bottom: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 50px;
        }
        
        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ff6b6b;
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: #5a3e36;
        }
        
        #game-board {
            position: relative;
            width: 100%;
            height: 280px;
            background: rgba(255, 237, 237, 0.7);
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(255, 107, 107, 0.2);
            margin-bottom: 12px;
            overflow: hidden;
            perspective: 1000px;
        }
        
        .card {
            position: absolute;
            width: 45px;
            height: 55px;
            border-radius: 6px;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 5;
            transform-style: preserve-3d;
            transform: translateZ(0);
        }
        
        .card:active {
            transform: scale(0.85) translateZ(0);
            box-shadow: 0 0 10px #ff6b6b;
            z-index: 100;
        }
        
        .card.covered {
            background: linear-gradient(135deg, #ffd166, #ff9a9e);
            color: rgba(255, 255, 255, 0.7);
        }
        
        .card.covered::after {
            content: "?";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            color: white;
            font-weight: bold;
        }
        
        .slot-area {
            display: flex;
            justify-content: center;
            gap: 5px;
            height: 60px;
            width: 100%;
            margin-top: 6px;
            padding: 8px;
            background: rgba(255, 214, 214, 0.6);
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            flex-wrap: wrap;
        }
        
        .slot {
            width: 40px;
            height: 40px;
            border: 2px dashed #ff6b6b;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.6);
            transition: all 0.2s;
            position: relative;
        }
        
        .slot.filled {
            border-style: solid;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .powerups {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            width: 100%;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .powerup {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            position: relative;
        }
        
        .powerup-count {
            position: absolute;
            bottom: -3px;
            right: -3px;
            background: #ff6b6b;
            color: white;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 9px;
            font-weight: bold;
        }
        
        .powerup:active {
            transform: scale(0.95);
        }
        
        .powerup.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        button {
            padding: 7px 12px;
            border: none;
            border-radius: 30px;
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            font-weight: bold;
            font-size: 0.85rem;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(255, 107, 107, 0.3);
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        #message {
            margin-top: 12px;
            min-height: 35px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #ff6b6b;
            text-align: center;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 30px;
            width: 100%;
            max-width: 450px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* 烟花特效容器 */
        #fireworks {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }
        
        .level-indicator {
            position: absolute;
            top: 12px;
            right: 12px;
            background: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            color: #ff6b6b;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            z-index: 20;
            font-size: 0.8rem;
        }
        
        .difficulty-info {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 10px;
            margin-top: 12px;
            max-width: 450px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            text-align: center;
            font-size: 0.8rem;
        }
        
        .difficulty-info h3 {
            color: #ff6b6b;
            margin-bottom: 6px;
            font-size: 1rem;
        }
        
        .difficulty-info p {
            margin-bottom: 5px;
            line-height: 1.3;
        }
        
        .level-progress {
            width: 100%;
            height: 12px;
            background: rgba(255, 107, 107, 0.2);
            border-radius: 6px;
            margin-top: 6px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
            border-radius: 6px;
            width: 0%;
            transition: width 0.4s ease;
        }
        
        /* 性能模式开关 */
        .performance-toggle {
            position: absolute;
            top: 12px;
            left: 12px;
            background: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            color: #ff6b6b;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            z-index: 20;
            font-size: 0.8rem;
            cursor: pointer;
        }
        
        /* 堆叠效果增强 */
        .card.stack-1 {
            transform: translate(-1px, -1px) rotate(-1deg) translateZ(1px);
        }
        
        .card.stack-2 {
            transform: translate(1px, 1px) rotate(1deg) translateZ(2px);
        }
        
        .card.stack-3 {
            transform: translate(-2px, 2px) rotate(-2deg) translateZ(3px);
        }
        
        .card.stack-4 {
            transform: translate(2px, -1px) rotate(2deg) translateZ(4px);
        }
        
        .card.stack-5 {
            transform: translate(0px, 2px) rotate(0deg) translateZ(5px);
        }
        
        /* 移动设备特定样式 */
        @media (max-width: 480px) {
            .header h1 { font-size: 1.4rem; }
            .header p { font-size: 0.8rem; }
            #game-board { height: 230px; }
            .stat-value { font-size: 1rem; }
            .stat-label { font-size: 0.65rem; }
            .card { width: 40px; height: 50px; font-size: 22px; }
            .slot { width: 36px; height: 36px; font-size: 18px; }
            .powerup { width: 36px; height: 36px; font-size: 16px; }
            button { padding: 6px 10px; font-size: 0.8rem; }
            .difficulty-info { padding: 8px; font-size: 0.75rem; }
            .difficulty-info h3 { font-size: 0.9rem; }
        }
        
        @media (max-width: 360px) {
            .header h1 { font-size: 1.3rem; }
            #game-board { height: 200px; }
            .card { width: 36px; height: 45px; font-size: 20px; }
            .slot { width: 32px; height: 32px; font-size: 16px; }
            .powerup { width: 32px; height: 32px; font-size: 15px; }
            .difficulty-info { font-size: 0.7rem; }
            .difficulty-info h3 { font-size: 0.85rem; }
            button { font-size: 0.75rem; }
        }
        
        /* 横屏模式优化 */
        @media (orientation: landscape) and (max-height: 500px) {
            .header { margin: 3px 0; }
            .header h1 { font-size: 1.2rem; }
            .header p { display: none; }
            .stats-bar { padding: 4px 8px; margin-bottom: 4px; }
            #game-board { height: 150px; margin-bottom: 4px; }
            .slot-area { height: 45px; padding: 4px; }
            .controls { margin-top: 4px; }
            .powerups { margin-top: 4px; }
            .difficulty-info { display: none; }
            #message { margin-top: 4px; min-height: 25px; font-size: 0.8rem; padding: 4px 8px; }
            .card { width: 35px; height: 45px; }
        }
        
        /* 堆叠指示器 */
        .stack-indicator {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 10px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        /* 新添加的提示效果 */
        .hint-highlight {
            animation: pulse 1s infinite;
            box-shadow: 0 0 10px gold;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .covered-count {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 10px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="performance-toggle" id="perf-toggle">⚡性能模式</div>
    
    <div class="header">
        <h1>🎂 生日羊了个羊 🎁</h1>
        <p>收集相同的生日元素，三个一组消除！</p>
    </div>
    
    <div class="level-indicator">关卡: <span id="level">1</span></div>
    
    <div class="game-container">
        <div class="stats-bar">
            <div class="stat">
                <div class="stat-value" id="moves">0</div>
                <div class="stat-label">步数</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="score">0</div>
                <div class="stat-label">分数</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="remaining">25</div>
                <div class="stat-label">剩余卡片</div>
            </div>
        </div>
        
        <div id="game-board"></div>
        
        <div class="slot-area" id="slot-area">
            <!-- 卡槽将由JS动态生成 -->
        </div>
        
        <div class="powerups">
            <div class="powerup" id="shuffle-power" title="洗牌">
                🔀
                <div class="powerup-count" id="shuffle-count">3</div>
            </div>
            <div class="powerup" id="undo-power" title="撤销">
                ↩️
                <div class="powerup-count" id="undo-count">5</div>
            </div>
            <div class="powerup" id="hint-power" title="提示">
                💡
                <div class="powerup-count" id="hint-count">2</div>
            </div>
            <div class="powerup" id="bomb-power" title="消除">
                💣
                <div class="powerup-count" id="bomb-count">2</div>
            </div>
        </div>
        
        <div class="controls">
            <button id="shuffle">🔀 洗牌</button>
            <button id="undo">↩️ 撤销</button>
            <button id="restart">🔄 重玩</button>
        </div>
        
        <div id="message">祝您生日快乐！点击卡片开始游戏~</div>
    </div>
    
    <div class="difficulty-info">
        <h3>当前关卡难度</h3>
        <p>卡片种类: <span id="card-types">6</span> | 卡片总数: <span id="total-cards">25</span></p>
        <p>卡槽数量: <span id="slot-count">7</span> | 覆盖层数: <span id="layer-count">3</span></p>
        <div class="level-progress">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
    </div>
    
    <div id="fireworks"></div>

    <script>
        // 生日主题元素
        const BIRTHDAY_ITEMS = ['🎂', '🎁', '🎈', '🎉', '🕯️', '🍰', '🍬', '🎀', '🍭', '🥳', '🎊', '🎆'];
        
        // 游戏配置
        const DIFFICULTY_SETTINGS = {
            typesPerLevel: 1,
            cardsPerLevel: 3,
            slotsReductionPerTwoLevels: 1,
            layersPerThreeLevels: 1,
            baseTypes: 6,
            baseCards: 25,
            baseSlots: 7,
            baseLayers: 3
        };
        
        // 游戏状态
        const gameState = {
            board: [],
            slots: [],
            selectedCard: null,
            moves: 0,
            score: 0,
            level: 1,
            history: [],
            powerups: {
                shuffle: 3,
                undo: 5,
                hint: 2,
                bomb: 2
            },
            cards: [],
            cardData: [],
            isAnimating: false,
            lowPerfMode: false,
            coveredCards: {} // 跟踪每张卡片被覆盖的数量
        };
        
        // DOM 元素
        const gameBoard = document.getElementById('game-board');
        const slotArea = document.getElementById('slot-area');
        const messageEl = document.getElementById('message');
        const movesEl = document.getElementById('moves');
        const scoreEl = document.getElementById('score');
        const remainingEl = document.getElementById('remaining');
        const levelEl = document.getElementById('level');
        const cardTypesEl = document.getElementById('card-types');
        const totalCardsEl = document.getElementById('total-cards');
        const slotCountEl = document.getElementById('slot-count');
        const layerCountEl = document.getElementById('layer-count');
        const progressBar = document.getElementById('progress-bar');
        const perfToggle = document.getElementById('perf-toggle');
        
        // 计算当前关卡难度
        function calculateDifficulty() {
            const level = gameState.level;
            
            const cardTypes = Math.min(
                DIFFICULTY_SETTINGS.baseTypes + (level - 1) * DIFFICULTY_SETTINGS.typesPerLevel,
                BIRTHDAY_ITEMS.length
            );
            
            // 确保卡片总数是3的倍数
            let totalCards = DIFFICULTY_SETTINGS.baseCards + (level - 1) * DIFFICULTY_SETTINGS.cardsPerLevel;
            totalCards = totalCards - (totalCards % 3);
            
            const slotCount = Math.max(
                3, 
                DIFFICULTY_SETTINGS.baseSlots - Math.floor((level - 1) / 2) * DIFFICULTY_SETTINGS.slotsReductionPerTwoLevels
            );
            
            const layers = Math.min(
                5, 
                DIFFICULTY_SETTINGS.baseLayers + Math.floor((level - 1) / 3) * DIFFICULTY_SETTINGS.layersPerThreeLevels
            );
            
            cardTypesEl.textContent = cardTypes;
            totalCardsEl.textContent = totalCards;
            slotCountEl.textContent = slotCount;
            layerCountEl.textContent = layers;
            progressBar.style.width = `${Math.min(100, level * 8)}%`;
            
            return { cardTypes, totalCards, slotCount, layers };
        }
        
        // 初始化游戏
        function initGame() {
            const difficulty = calculateDifficulty();
            
            gameState.board = [];
            gameState.slots = Array(difficulty.slotCount).fill(null);
            gameState.selectedCard = null;
            gameState.history = [];
            gameState.cards = [];
            gameState.cardData = [];
            gameState.isAnimating = false;
            gameState.coveredCards = {};
            
            gameState.powerups = {
                shuffle: Math.max(1, 4 - Math.floor(gameState.level / 3)),
                undo: Math.max(1, 6 - Math.floor(gameState.level / 2)),
                hint: Math.max(1, 3 - Math.floor(gameState.level / 4)),
                bomb: Math.max(1, 3 - Math.floor(gameState.level / 4))
            };
            
            updatePowerups();
            
            movesEl.textContent = gameState.moves;
            scoreEl.textContent = gameState.score;
            remainingEl.textContent = difficulty.totalCards;
            levelEl.textContent = gameState.level;
            messageEl.textContent = `第${gameState.level}关：祝您生日快乐！`;
            
            const items = [];
            const cardTypes = difficulty.cardTypes;
            const totalCards = difficulty.totalCards;
            
            // 确保每种类型的卡片数量是3的倍数
            const cardsPerType = Math.floor(totalCards / cardTypes);
            let baseCards = cardsPerType - (cardsPerType % 3);
            let remainingCards = totalCards - (baseCards * cardTypes);
            
            for (let i = 0; i < cardTypes; i++) {
                const item = BIRTHDAY_ITEMS[i % BIRTHDAY_ITEMS.length];
                for (let j = 0; j < baseCards; j++) {
                    items.push(item);
                }
            }
            
            // 分配剩余的卡片（以3为单位）
            while (remainingCards > 0) {
                const randomType = Math.floor(Math.random() * cardTypes);
                const item = BIRTHDAY_ITEMS[randomType % BIRTHDAY_ITEMS.length];
                for (let j = 0; j < 3; j++) {
                    items.push(item);
                }
                remainingCards -= 3;
            }
            
            shuffleArray(items);
            
            gameBoard.innerHTML = '';
            gameState.board = items;
            
            renderCards(difficulty.layers);
            
            createSlots(difficulty.slotCount);
        }
        
        // 创建卡槽
        function createSlots(slotCount) {
            slotArea.innerHTML = '';
            for (let i = 0; i < slotCount; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.dataset.index = i;
                slotArea.appendChild(slot);
            }
        }
        
        // 渲染卡片（增加堆叠效果）
        function renderCards(maxLayers) {
            gameBoard.innerHTML = '';
            gameState.cards = [];
            gameState.cardData = [];
            gameState.coveredCards = {};
            
            const boardWidth = gameBoard.clientWidth;
            const boardHeight = gameBoard.clientHeight;
            
            // 根据屏幕尺寸调整卡片大小
            const cardWidth = window.innerWidth < 480 ? 40 : 45;
            const cardHeight = window.innerWidth < 480 ? 50 : 55;
            
            // 网格布局参数
            let gridCols = Math.max(1, Math.floor(boardWidth / (cardWidth + 8)));
            let gridRows = Math.max(1, Math.floor(boardHeight / (cardHeight + 8)));
            
            // 确保网格可以容纳所有卡片
            while (gridCols * gridRows < gameState.board.length) {
                if (gridCols < gridRows) {
                    gridCols++;
                } else {
                    gridRows++;
                }
            }
            
            const gridSize = gridCols * gridRows;
            
            // 创建网格位置
            const gridPositions = [];
            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const x = col * (cardWidth + 8) + 10;
                    const y = row * (cardHeight + 8) + 10;
                    gridPositions.push({x, y});
                }
            }
            
            // 打乱网格位置
            shuffleArray(gridPositions);
            
            // 堆叠计数器
            const stackCount = {};
            
            // 为每张卡片分配位置
            for (let i = 0; i < gameState.board.length; i++) {
                const pos = gridPositions[i % gridSize];
                
                // 计算堆叠位置
                const stackKey = `${Math.floor(pos.x/10)}-${Math.floor(pos.y/10)}`;
                stackCount[stackKey] = (stackCount[stackKey] || 0) + 1;
                const stackLevel = stackCount[stackKey] % 5;
                
                // 随机旋转角度
                const rotation = (Math.random() - 0.5) * 10;
                
                // 随机层级
                const zIndex = Math.floor(Math.random() * maxLayers);
                
                // 存储卡片数据
                gameState.cardData.push({
                    x: pos.x, y: pos.y, width: cardWidth, height: cardHeight, zIndex, stackLevel
                });
                
                const card = document.createElement('div');
                card.className = `card stack-${stackLevel}`;
                card.dataset.index = i;
                card.textContent = gameState.board[i];
                card.style.left = `${pos.x}px`;
                card.style.top = `${pos.y}px`;
                card.style.width = `${cardWidth}px`;
                card.style.height = `${cardHeight}px`;
                card.style.zIndex = zIndex;
                
                // 添加堆叠指示器
                const stackIndicator = document.createElement('div');
                stackIndicator.className = 'stack-indicator';
                stackIndicator.textContent = stackLevel + 1;
                card.appendChild(stackIndicator);
                
                // 添加覆盖数量指示器
                const coveredIndicator = document.createElement('div');
                coveredIndicator.className = 'covered-count';
                coveredIndicator.textContent = '0';
                card.appendChild(coveredIndicator);
                
                if (zIndex < maxLayers - 1) {
                    card.classList.add('covered');
                }
                
                // 添加事件监听
                card.addEventListener('click', () => selectCard(card, i));
                
                gameBoard.appendChild(card);
                gameState.cards.push(card);
            }
            
            // 计算每张卡片被覆盖的数量
            calculateCoveredCounts();
        }
        
        // 计算每张卡片被覆盖的数量
        function calculateCoveredCounts() {
            const maxLayers = calculateDifficulty().layers;
            
            for (let i = 0; i < gameState.cardData.length; i++) {
                const card = gameState.cardData[i];
                if (!card) continue;
                
                let coveredCount = 0;
                
                for (let j = 0; j < gameState.cardData.length; j++) {
                    if (i === j) continue;
                    const otherCard = gameState.cardData[j];
                    if (!otherCard) continue;
                    
                    if (otherCard.zIndex > card.zIndex) {
                        if (isOverlapping(card, otherCard)) {
                            coveredCount++;
                        }
                    }
                }
                
                gameState.coveredCards[i] = coveredCount;
                
                // 更新卡片上的指示器
                const cardElement = gameState.cards[i];
                if (cardElement) {
                    const coveredIndicator = cardElement.querySelector('.covered-count');
                    if (coveredIndicator) {
                        coveredIndicator.textContent = coveredCount;
                    }
                }
            }
        }
        
        // 检查两张卡片是否重叠
        function isOverlapping(card1, card2) {
            return card1.x < card2.x + card2.width &&
                   card1.x + card1.width > card2.x &&
                   card1.y < card2.y + card2.height &&
                   card1.y + card1.height > card2.y;
        }
        
        // 洗牌算法
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // 卡片移动动画（优化版本）
        function animateCardToSlot(cardElement, slotElement, callback) {
            if (gameState.isAnimating) return;
            
            gameState.isAnimating = true;
            
            const card = cardElement.cloneNode(true);
            card.style.position = 'fixed';
            card.style.left = `${cardElement.getBoundingClientRect().left}px`;
            card.style.top = `${cardElement.getBoundingClientRect().top}px`;
            card.style.zIndex = '1000';
            card.style.transition = 'transform 0.4s ease, opacity 0.4s ease';
            document.body.appendChild(card);
            
            // 强制重绘
            card.offsetHeight;
            
            const slotRect = slotElement.getBoundingClientRect();
            
            // 执行动画
            card.style.transform = `translate(${slotRect.left}px, ${slotRect.top}px) scale(0.7)`;
            card.style.opacity = '0.8';
            
            setTimeout(() => {
                card.remove();
                callback();
                gameState.isAnimating = false;
            }, 400);
        }
        
        // 检测卡片是否被覆盖
        function isCardCovered(cardIndex) {
            return gameState.coveredCards[cardIndex] > 0;
        }
        
        // 选择卡片
        function selectCard(card, index) {
            if (gameState.isAnimating) return;
            if (isCardCovered(index)) {
                messageEl.textContent = `这张卡片被覆盖了！请先移开上层的卡片（覆盖数: ${gameState.coveredCards[index]})`;
                
                const cardElement = gameState.cards[index];
                cardElement.style.boxShadow = '0 0 0 2px red';
                setTimeout(() => {
                    if (cardElement) cardElement.style.boxShadow = '';
                }, 1000);
                
                return;
            }
            
            if (gameState.selectedCard) {
                gameState.selectedCard.classList.remove('selected');
            }
            
            card.classList.add('selected');
            gameState.selectedCard = card;
            
            placeCardInSlot(gameState.board[index]);
        }
        
        // 将卡片放入卡槽
        function placeCardInSlot(item) {
            const emptySlotIndex = gameState.slots.findIndex(slot => slot === null);
            
            if (emptySlotIndex === -1) {
                messageEl.textContent = '卡槽已满！请先消除卡片';
                return;
            }
            
            const cardIndex = parseInt(gameState.selectedCard.dataset.index);
            const targetSlot = document.querySelector(`.slot[data-index="${emptySlotIndex}"]`);
            
            animateCardToSlot(gameState.selectedCard, targetSlot, () => {
                gameState.history.push({
                    board: [...gameState.board],
                    slots: [...gameState.slots],
                    movedItem: item,
                    slotIndex: emptySlotIndex,
                    selectedIndex: cardIndex
                });
                
                gameState.slots[emptySlotIndex] = item;
                gameState.board[cardIndex] = null;
                gameState.cardData[cardIndex] = null;
                gameState.moves++;
                movesEl.textContent = gameState.moves;
                
                const remaining = gameState.board.filter(item => item !== null).length;
                remainingEl.textContent = remaining;
                
                updateSlots();
                
                gameState.selectedCard.style.visibility = 'hidden';
                gameState.selectedCard.classList.remove('selected');
                gameState.selectedCard = null;
                
                const match = checkForMatches();
                if (!match) {
                    messageEl.textContent = '继续寻找相同的元素！';
                }
                
                // 重新计算覆盖状态
                calculateCoveredCounts();
                checkGameEnd();
            });
        }
        
        // 更新卡槽显示
        function updateSlots() {
            const slots = document.querySelectorAll('.slot');
            slots.forEach((slot, index) => {
                if (gameState.slots[index]) {
                    slot.className = 'slot filled';
                    slot.textContent = gameState.slots[index];
                } else {
                    slot.className = 'slot';
                    slot.innerHTML = '';
                }
            });
        }
        
        // 检查是否有可消除的组合
        function checkForMatches() {
            const slotItems = gameState.slots.filter(item => item !== null);
            const counts = {};
            
            slotItems.forEach(item => {
                counts[item] = (counts[item] || 0) + 1;
            });
            
            for (const item in counts) {
                if (counts[item] >= 3) {
                    let removed = 0;
                    for (let i = 0; i < gameState.slots.length && removed < 3; i++) {
                        if (gameState.slots[i] === item) {
                            gameState.slots[i] = null;
                            removed++;
                        }
                    }
                    
                    gameState.score += 100 * gameState.level;
                    scoreEl.textContent = gameState.score;
                    
                    messageEl.textContent = `消除成功！${item} x3 +${100 * gameState.level}分`;
                    updateSlots();
                    return true;
                }
            }
            return false;
        }
        
        // 检查游戏是否结束
        function checkGameEnd() {
            if (gameState.board.every(item => item === null)) {
                messageEl.textContent = `🎉 恭喜！您通关第${gameState.level}关！`;
                
                // 显示烟花效果
                showSimpleFireworks();
                
                setTimeout(() => {
                    gameState.level++;
                    initGame();
                }, 1500);
                return true;
            }
            
            const hasEmptySlot = gameState.slots.some(slot => slot === null);
            if (!hasEmptySlot && !checkForMatches()) {
                messageEl.textContent = '卡槽满了！游戏结束';
                setTimeout(() => {
                    if (confirm(`第${gameState.level}关失败！是否重新开始？`)) {
                        gameState.level = 1;
                        gameState.score = 0;
                        gameState.moves = 0;
                        initGame();
                    }
                }, 500);
                return true;
            }
            
            return false;
        }
        
        // 显示简单烟花特效
        function showSimpleFireworks() {
            const fireworks = document.createElement('div');
            fireworks.style.position = 'fixed';
            fireworks.style.top = '50%';
            fireworks.style.left = '50%';
            fireworks.style.transform = 'translate(-50%, -50%)';
            fireworks.style.fontSize = '60px';
            fireworks.style.zIndex = '100';
            fireworks.style.opacity = '0';
            fireworks.style.transition = 'opacity 0.5s, transform 0.5s';
            fireworks.textContent = '🎉';
            
            document.body.appendChild(fireworks);
            
            // 触发动画
            setTimeout(() => {
                fireworks.style.opacity = '1';
                fireworks.style.transform = 'translate(-50%, -50%) scale(1.5)';
            }, 10);
            
            // 移除烟花
            setTimeout(() => {
                fireworks.style.opacity = '0';
                setTimeout(() => fireworks.remove(), 500);
            }, 1000);
        }
        
        // 撤销操作
        function undoMove() {
            if (gameState.isAnimating) return;
            if (gameState.history.length === 0) {
                messageEl.textContent = '没有可撤销的操作';
                return;
            }
            
            if (gameState.powerups.undo <= 0) {
                messageEl.textContent = '撤销次数已用完';
                return;
            }
            
            gameState.powerups.undo--;
            updatePowerups();
            
            const lastMove = gameState.history.pop();
            gameState.board = lastMove.board;
            gameState.slots = lastMove.slots;
            gameState.moves--;
            
            updateSlots();
            const difficulty = calculateDifficulty();
            renderCards(difficulty.layers);
            
            if (lastMove.selectedIndex !== null) {
                const card = document.querySelector(`.card[data-index="${lastMove.selectedIndex}"]`);
                if (card) {
                    card.classList.add('selected');
                    card.style.visibility = 'visible';
                    gameState.selectedCard = card;
                }
            }
            
            movesEl.textContent = gameState.moves;
            const remaining = gameState.board.filter(item => item !== null).length;
            remainingEl.textContent = remaining;
            
            messageEl.textContent = '已撤销上一步操作';
        }
        
        // 洗牌功能
        function shuffleBoard() {
            if (gameState.isAnimating) return;
            if (gameState.powerups.shuffle <= 0) {
                messageEl.textContent = '洗牌次数已用完';
                return;
            }
            
            gameState.powerups.shuffle--;
            updatePowerups();
            
            const visibleItems = gameState.board.filter(item => item !== null);
            shuffleArray(visibleItems);
            
            let itemIndex = 0;
            gameState.board.forEach((item, index) => {
                if (item !== null) {
                    gameState.board[index] = visibleItems[itemIndex++];
                }
            });
            
            const difficulty = calculateDifficulty();
            renderCards(difficulty.layers);
            messageEl.textContent = '卡片已洗牌！';
        }
        
        // 提示功能
        function showHint() {
            if (gameState.isAnimating) return;
            if (gameState.powerups.hint <= 0) {
                messageEl.textContent = '提示次数已用完';
                return;
            }
            
            gameState.powerups.hint--;
            updatePowerups();
            
            // 1. 首先检查卡槽中是否有两个相同的卡片
            const slotCounts = {};
            gameState.slots.forEach(item => {
                if (item) {
                    slotCounts[item] = (slotCounts[item] || 0) + 1;
                }
            });
            
            for (const item in slotCounts) {
                if (slotCounts[item] >= 2) {
                    // 尝试在牌堆中找到第三个相同的卡片
                    for (let i = 0; i < gameState.board.length; i++) {
                        if (gameState.board[i] === item && !isCardCovered(i)) {
                            const card = document.querySelector(`.card[data-index="${i}"]`);
                            if (card) {
                                card.classList.add('hint-highlight');
                                setTimeout(() => {
                                    card.classList.remove('hint-highlight');
                                }, 1500);
                                
                                messageEl.textContent = `卡槽中有两个${item}，点击牌堆中的${item}完成消除！`;
                                return;
                            }
                        }
                    }
                }
            }
            
            // 2. 如果没有找到卡槽中的配对，则找牌堆中的配对
            let found = false;
            for (let i = 0; i < gameState.board.length && !found; i++) {
                if (gameState.board[i] === null || isCardCovered(i)) continue;
                
                for (let j = i + 1; j < gameState.board.length; j++) {
                    if (gameState.board[j] && gameState.board[i] === gameState.board[j] && !isCardCovered(j)) {
                        const card1 = document.querySelector(`.card[data-index="${i}"]`);
                        const card2 = document.querySelector(`.card[data-index="${j}"]`);
                        
                        if (card1 && card2) {
                            card1.classList.add('hint-highlight');
                            card2.classList.add('hint-highlight');
                            
                            setTimeout(() => {
                                card1.classList.remove('hint-highlight');
                                card2.classList.remove('hint-highlight');
                            }, 1500);
                            
                            messageEl.textContent = '找到一对相同的卡片！';
                            found = true;
                            break;
                        }
                    }
                }
            }
            
            if (!found) {
                messageEl.textContent = '没有找到可匹配的卡片';
            }
        }
        
        // 炸弹功能
        function useBomb() {
            if (gameState.isAnimating) return;
            if (gameState.powerups.bomb <= 0) {
                messageEl.textContent = '炸弹次数已用完';
                return;
            }
            
            gameState.powerups.bomb--;
            updatePowerups();
            
            const slotIndex = gameState.slots.findIndex(slot => slot !== null);
            if (slotIndex === -1) {
                messageEl.textContent = '卡槽为空，无法使用炸弹';
                return;
            }
            
            // 直接移除
            gameState.slots[slotIndex] = null;
            updateSlots();
            messageEl.textContent = '已移除一个卡片元素';
        }
        
        // 更新道具显示
        function updatePowerups() {
            document.getElementById('shuffle-count').textContent = gameState.powerups.shuffle;
            document.getElementById('undo-count').textContent = gameState.powerups.undo;
            document.getElementById('hint-count').textContent = gameState.powerups.hint;
            document.getElementById('bomb-count').textContent = gameState.powerups.bomb;
            
            document.getElementById('shuffle-power').classList.toggle('disabled', gameState.powerups.shuffle <= 0);
            document.getElementById('undo-power').classList.toggle('disabled', gameState.powerups.undo <= 0);
            document.getElementById('hint-power').classList.toggle('disabled', gameState.powerups.hint <= 0);
            document.getElementById('bomb-power').classList.toggle('disabled', gameState.powerups.bomb <= 0);
        }
        
        // 切换性能模式
        function togglePerformanceMode() {
            gameState.lowPerfMode = !gameState.lowPerfMode;
            
            if (gameState.lowPerfMode) {
                perfToggle.textContent = '⚡流畅模式';
                messageEl.textContent = '已启用流畅模式（减少特效）';
            } else {
                perfToggle.textContent = '⚡性能模式';
                messageEl.textContent = '已启用性能模式（更多特效）';
            }
            
            // 重新渲染卡片
            const difficulty = calculateDifficulty();
            renderCards(difficulty.layers);
        }
        
        // 事件监听
        document.getElementById('shuffle').addEventListener('click', shuffleBoard);
        document.getElementById('undo').addEventListener('click', undoMove);
        document.getElementById('restart').addEventListener('click', () => {
            gameState.level = 1;
            gameState.score = 0;
            gameState.moves = 0;
            initGame();
        });
        
        document.getElementById('shuffle-power').addEventListener('click', shuffleBoard);
        document.getElementById('undo-power').addEventListener('click', undoMove);
        document.getElementById('hint-power').addEventListener('click', showHint);
        document.getElementById('bomb-power').addEventListener('click', useBomb);
        perfToggle.addEventListener('click', togglePerformanceMode);
        
        // 初始化游戏
        window.onload = () => {
            initGame();
            
            // 添加窗口大小变化监听
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (!gameState.isAnimating) {
                        const difficulty = calculateDifficulty();
                        renderCards(difficulty.layers);
                    }
                }, 300);
            });
        };
    </script>
</body>
</html>
